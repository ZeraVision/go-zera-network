syntax = "proto3";

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";
import "txn.proto";

package zera_validator;

option go_package = "./grpc/protobuf";

option optimize_for = SPEED;

service ValidatorService{
    rpc StreamBroadcast(stream DataChunk) returns (google.protobuf.Empty);
    rpc Broadcast(Block) returns (google.protobuf.Empty);
    rpc SyncBlockchain(BlockSync) returns (stream DataChunk);
    rpc ValidatorRegistration(zera_txn.ValidatorRegistration) returns (google.protobuf.Empty);
    rpc SyncValidatorList(ValidatorSyncRequest) returns (ValidatorSync);
    rpc ValidatorCoin(zera_txn.CoinTXN) returns (google.protobuf.Empty);
    rpc ValidatorMint(zera_txn.MintTXN) returns (google.protobuf.Empty);
    rpc ValidatorItemMint(zera_txn.ItemizedMintTXN) returns (google.protobuf.Empty);
    rpc ValidatorContract(zera_txn.InstrumentContract) returns (google.protobuf.Empty); 
    rpc ValidatorGovernProposal(zera_txn.GovernanceProposal) returns (google.protobuf.Empty);
    rpc ValidatorGovernVote(zera_txn.GovernanceVote) returns (google.protobuf.Empty);
    rpc ValidatorSmartContract(zera_txn.SmartContractTXN) returns (google.protobuf.Empty);
    rpc ValidatorSmartContractExecute(zera_txn.SmartContractExecuteTXN) returns (google.protobuf.Empty);
    rpc ValidatorCurrencyEquiv(zera_txn.SelfCurrencyEquiv) returns (google.protobuf.Empty);
    rpc ValidatorAuthCurrencyEquiv(zera_txn.AuthorizedCurrencyEquiv) returns (google.protobuf.Empty);
    rpc ValidatorExpenseRatio(zera_txn.ExpenseRatioTXN) returns (google.protobuf.Empty);
    rpc ValidatorNFT(zera_txn.NFTTXN) returns (google.protobuf.Empty);
    rpc ValidatorContractUpdate(zera_txn.ContractUpdateTXN) returns (google.protobuf.Empty);
    rpc ValidatorHeartbeat(zera_txn.ValidatorHeartbeat) returns (google.protobuf.Empty);
    rpc ValidatorFoundation(zera_txn.FoundationTXN) returns (google.protobuf.Empty);
    rpc ValidatorDelegatedVoting(zera_txn.DelegatedVotingTXN) returns (google.protobuf.Empty);
    rpc IndexerVoting(IndexerVotingRequest) returns (IndexerVotingResponse);
}

message DataChunk{
    bytes chunk_data = 1;
    int32 chunk_number = 2;
    optional int32 total_chunks = 3;
}
message ValidatorSyncRequest {
  bytes public_key = 1;
  bytes signature = 2;
}
message ValidatorSync{
    repeated zera_txn.Validator validators = 1;
    optional bytes signature = 2;
    bytes public_key = 3;
}

message BlockSync{
    bytes last_key = 1;
    uint64 amount = 2;
    optional bytes signature = 3;
    bytes public_key = 4;
}
message BlockHeader{
	optional uint64 version = 1;
	optional bytes previous_block_hash = 2;
    optional bytes hash = 3;
	google.protobuf.Timestamp timestamp = 4;
	uint64 nonce = 5;
	uint64 block_height = 6;
    bytes fee_address = 7;
    optional bytes signature = 8;
    bytes public_key = 9;
    optional bytes merkle_root = 10;
}
message Block{
	optional BlockHeader block_header = 1;
	zera_txn.TXNS transactions = 2;
	optional bytes signature = 4;
    optional bytes public_key = 5;
}
message BlockBatch{
    repeated Block blocks = 1;
    bool last_block = 2;
    optional bytes signature = 3;
    bytes public_key = 4;
}

message NFT{
    bytes holder_address = 1;
    string contract_id = 2;
    string item_id = 3;
    optional string voting_weight = 4;
    optional zera_txn.ItemContractFees contract_fees = 5;
}

message ProcessLedger{
    repeated bytes cycle_contract_ids = 1;
    repeated bytes proposal_ids = 2;
}
//message for a ledger to determine proposal_ids for contracts
//used to process cycle/staged governance
// Key = contract_id
message ProposalLedger{
    repeated bytes proposal_ids = 1;
    repeated bytes pending_proposal_ids = 2;
}
message Vote{
    map<string, string> vote = 1;
}
message Voter{
    bytes public_key = 1;
    optional bool support = 2;
    optional uint32 option = 3;
}
message VoteWallet{
    map<string, Voter> proposal_votes = 1;
}
message Proposal{
    string contract_id = 1;
    map<string, string> yes = 4;    //all votes for yes of each currency
    map<string, string> no = 5;     //all votes for no of each currency
    map<uint32, Vote> options = 6; //all votes for each option of each currency
    uint32 stage = 7;
    string fee = 8;
    string fee_id = 9;
    bytes wallet = 10;
    repeated Voter voters = 11; //wallets and amounts of each currency wallet has
    optional google.protobuf.Timestamp start_date = 12;
    optional google.protobuf.Timestamp end_date = 13;
}
message ProposalWalletRecieve{
    zera_txn.BaseTXN base = 1;
    bytes wallet_adr = 2;
    string contract_id = 3;
    string amount = 4;
}

message ProposalWalletSend{
    zera_txn.BaseTXN base = 1;
    bytes wallet_adr = 2;
    string contract_id = 3;
    repeated bytes recipient_wallet = 4;
    repeated string amounts = 5;
}
message CurrencyRate{
    bool qualified = 1;
    string rate = 2;
}
message ExpenseTracker{
    int32 day = 1;
    int32 month = 2;
}
message RestrictedSymbols{
    repeated string symbols = 1;
}

message IndexerVotingRequest{
    string proposal_id = 1;
}

//THIS IS NOT A PART OF ACTUAL VALIDATOR
message IndexerOption{
    repeated IndexerVote votes = 1;
    uint32 index = 2;
}
message IndexerVote{
    string contract_id = 1;
    string amount = 2;
}
message IndexerVotingResponse{
    repeated IndexerVote yes = 1;    //all votes for yes of each currency
    repeated IndexerVote no = 2;     //all votes for no of each currency
    repeated IndexerOption options = 3;  //all votes for each option of each currency
    uint32 stage = 4;
}
message DelegationFees{
    map<string, string> authorized_fees =3;
}
message DelegatedVote{
    map<string, DelegationFees> delegations = 1;
}
message Delegator{
    repeated bytes public_key = 1;
}
message DelegatedRecipient{
    map<string, Delegator> delegations = 1;
}